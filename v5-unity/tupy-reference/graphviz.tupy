### ABSTRA√á√ïES PERSONALIZADAS ###

# H√° suporte para renderiza√ß√£o de estruturas
# de dados usando o motor dot da ferramenta Graphviz.
# Isso foi tornado poss√≠vel gra√ßas √† biblioteca Viz.js.
# (https://github.com/mdaines/viz.js/)

# As fun√ß√µes a seguir possibilitam converter uma estrutura
# para uma cadeia contendo uma defini√ß√£o DOT que √©
# processada automaticamente pelo visualizador e
# renderizada como imagem, viabilizado a exibi√ß√£o de
# abstra√ß√µes personalizadas de estruturas de dados.

# O usu√°rio tamb√©m pode usar a linguagem DOT para renderizar
# estruturas arbitr√°rias em qualquer momento do programa
# armazenando os comandos em uma cadeia e passando-a como
# argumento para a fun√ß√£o dot():

# dot(<comandos>)

# Experimente o seguinte c√≥digo:

cadeia V <- dot("digraph G { 1 -> 2; 2 -> 3; 3 -> 1 }")

# Voc√™ pode aprender mais sobre a linguagem DOT com este
# guia (em ingl√™s): http://www.graphviz.org/pdf/dotguide.pdf

# Para tornar a visualiza√ß√£o mais idiom√°tica, a palavra-chave
# 'visual' pode ser usada com a mesma sem√¢ntica de 'cadeia' como
# especificador de tipo de dados.

# Para que os procedimentos de visualiza√ß√£o n√£o poluam a vis√£o
# do c√≥digo-fonte, especialmente em uma apresenta√ß√£o de um programa, √©
# poss√≠vel ocult√°-los com marcadores compostos por '~'.
# Veja mais informa√ß√µes na se√ß√£o 'manipula√ß√£o da visualiza√ß√£o'.

# Lista de fun√ß√µes dispon√≠veis:

# vetor, pilha, fila, matriz,
# lista_encadeada, heap, √°rvore,
# grafo_MA, grafo_LA, digrafo_MA, digrafo_LA,
# grafo_valorado_MA, grafo_valorado_LA,
# digrafo_valorado_MA, digrafo_valorado_LA, dot

#----------------------------------------------------------------------
## vetor(V, d = [], xc = "", xf = "")

# Par√¢metros:
#   V (lista unidimensional)
#   d (lista de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o vetor V ser√° renderizado.
# Opcionalmente, uma ou mais posi√ß√µes do vetor podem ser destacadas em outra
# cor. Para isso, especifique as posi√ß√µes de destaque na lista d. As cadeias xc e
# xf, tamb√©m opcionais, podem ser usadas para inserir comandos adicionais ao
# subprograma dot ao come√ßo e ao final da mesma estrutura 'digraph', respectivamente.

# Na defini√ß√£o gerada, o vetor inteiro √© uma tabela contida no n√≥ 1.
# Cada posi√ß√£o do vetor pode ser referenciada por '1:vY' em que Y √© o
# √≠ndice do elemento. Por exemplo, '2 -> 1:v0' cria um n√≥ 2 que aponta
# para o primeiro elemento do vetor.

# Tamb√©m √© poss√≠vel referenciar os cabe√ßalhos das colunas que est√£o
# identificados como '1:cY'.

inteiro V[*] <- [1, 5, 100, 7, 9]
visual X <- vetor(V)
visual X <- vetor(V, [1])
visual X <- vetor(V, [1], "node [shape=egg];")
visual X <- vetor(V, [1], "", "2 -> 1:v3:s; 2 [label=\"Veja!\"]; rankdir=\"BT\"")

#----------------------------------------------------------------------
## vetor(V, d, i, xc = "", xf = "")

# Par√¢metros:
#   V (lista unidimensional)
#   d (lista de inteiros)
#   i (inteiro)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o vetor V ser√° renderizado,
# sendo que o cabe√ßalho dos √≠ndices ser√° exibido come√ßando a contar de 'i'.
# Os √≠ndices dos elementos nas refer√™ncias 1:vY do programa GraphViz tamb√©m
# s√£o afetados pelo deslocamento de 'i'.

# As cadeias xc e xf s√£o interpretadas da mesma maneira da fun√ß√£o vetor acima.

inteiro V[*] <- [1, 5, 100, 7, 9]
visual X <- vetor(V[2..3], [], 2)
visual X <- vetor(V[2..3], [], 2, "node [shape=box3d];")
visual X <- vetor(V[2..3], [], 2, "", "2 -> 1:v3:s; 2 [label=\"Veja!\"]; rankdir=\"BT\"")

#----------------------------------------------------------------------
## pilha(V, d = [], xc = "", xf = "")

# Par√¢metros:
#   V (lista unidimensional)
#   d (lista de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o vetor V ser√° renderizado
# no formato de pilha. Os par√¢metros d, xc e xf funcionam da mesma maneira como
# na fun√ß√£o vetor.

# √â importante destacar que, na defini√ß√£o gerada, o n√≥ 0 √© reservado e
# invis√≠vel, localizado acima da pilha.

inteiro V[*] <- [1, 5, 100, 7, 9]
visual X <- pilha(V)
visual X <- pilha(V, [1])
visual X <- pilha(V, [1], "edge [color=red];")
visual X <- pilha(V, [1], "", "2 -> 1:v3:w; 2 [label=\"Veja!\"];"
                          " {rank=\"same\"; 1; 2}")

#----------------------------------------------------------------------
## fila(V, d = [], xc = "", xf = "")

# Par√¢metros:
#   V (lista unidimensional)
#   d (lista de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o vetor V ser√° renderizado
# no formato de fila. Os par√¢metros d, xc e xf funcionam da mesma maneira como
# na fun√ß√£o vetor.

# √â importante destacar que, na defini√ß√£o gerada, os n√≥s F e C s√£o reservados
# e invis√≠veis, localizados √† esquerda e √† direita da fila, respectivamente.

inteiro V[*] <- [1, 5, 100, 7, 9]
visual X <- fila(V)
visual X <- fila(V, [1])
visual X <- fila(V, [1], "edge [arrowhead=invodot];")
visual X <- fila(V, [1], "", "2 -> C; 2 [label=\"Come√ßo da fila!\"];"
                         "3 -> F; 3 [label=\"Fim da fila!\"];")

#----------------------------------------------------------------------
## matriz(M, d = [], xc = "", xf = "")

# Par√¢metros:
#   M (lista bidimensional)
#   d (lista de pares [x, y] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, a matriz M ser√° renderizada.
# Opcionalmente, uma ou mais posi√ß√µes da matriz podem ser destacadas em outra
# cor. Para isso, especifique as posi√ß√µes de destaque na lista d. As cadeias xc
# e xf, tamb√©m opcionais, podem ser usadas para inserir comandos adicionais ao
# subprograma dot ao come√ßo e ao final da mesma estrutura 'digraph', respectivamente.

# Na defini√ß√£o gerada, a matriz inteira √© uma tabela contida no n√≥ 1.
# Cada posi√ß√£o da matriz pode ser referenciada por '1:vI_J' em que I √© a
# linha e J a coluna do elemento. Por exemplo, '2 -> 1:v0_1' cria um n√≥ 2
# que aponta para o segundo elemento da primeira linha da matriz.

# Tamb√©m √© poss√≠vel referenciar os cabe√ßalhos das colunas e prefixos das
# linhas, que est√£o identificados como '1:cJ' e '1:rI' respectivamente.
# O identificador '1:rc' aponta para a c√©lula vazia √† esquerda do primeiro
# cabe√ßalho de coluna.

inteiro M[*,*] <- [ [1, 2, 7],
                    [4, 8, 5],
                    [9, 3, 6] ]
visual X <- matriz(M)
visual X <- matriz(M, [[1,2], [0,0]])
visual X <- matriz(M, [[1,2], [0,0]], "bgcolor=navy;")
visual X <- matriz(M, [[1,2], [0,0]], "", "2 -> 1:v2_2:e; 2 [label=\"Veja!\"]; "
                                      "rankdir=\"BT\"")

#----------------------------------------------------------------------
## matriz(M, d, i, j, xc = "", xf = "")

# Par√¢metros:
#   M (lista bidimensional)
#   d (lista de pares [x, y] de inteiros)
#   i (inteiro)
#   j (inteiro)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, a matriz M ser√° renderizado,
# sendo que os √≠ndices das linhas ser√£o exibidos come√ßando a contar de 'i', e os
# √≠ndices das colunas ser√£o exibidos come√ßando a contar de 'j'.
# Os √≠ndices dos elementos nas refer√™ncias 1:vI_J do programa GraphViz tamb√©m
# s√£o afetados pelos deslocamentos de 'i' e de 'j'.

# As cadeias xc e xf s√£o interpretadas da mesma maneira da fun√ß√£o matriz acima.

inteiro M[*,*] <- [ [1, 2, 7],
                    [4, 8, 5],
                    [9, 3, 6] ]
visual X <- matriz(M[1..2, 0..1], [], 1, 0)
visual X <- matriz(M[1..2, 0..1], [], 1, 0, "rotate=90;")
visual X <- matriz(M[1..2, 0..1], [], 1, 0, "", "2 -> 1:v1_1:nw; 2 [label=\"Veja!\"];")

#----------------------------------------------------------------------
## lista_encadeada(cab, nc, np, dupl? = falso, d = [], xc = "", xf = "")

# Par√¢metros:
#   cab (estrutura)
#   nc (cadeia)
#   np (cadeia)
#   dupl? (l√≥gico)
#   d (lista de estruturas)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, a lista_encadeada partindo do
# n√≥ 'cab' ser√° renderizada. As cadeias nc e np devem fornecer os nomes dos atributos
# definidos na classe de cab que simbolizam, respectivamente, o valor da chave
# e a refer√™ncia de pr√≥ximo elemento da lista. Caso 'dupl?' seja verdadeiro, a lista
# ser√° renderizada como duplamente encadeada.

# Na defini√ß√£o gerada, os n√≥s podem ser identificados por 'sX' onde X √© a posi√ß√£o do
# n√≥ na lista fornecida, partindo do zero. Tamb√©m √© poss√≠vel endere√ßar especificamente
# a chave de um n√≥ usando 'sX:nc', em que nc √© o valor da vari√°vel nc, o ponteiro de
# pr√≥ximo usando 'sX:r', ou o ponteiro de anterior (no caso de listas duplamente
# encadeadas) usando 'sX:l'. Caso a lista n√£o seja circular, o elemento 'nulo' (fim da
# lista) √© endere√ß√°vel atrav√©s do nome 'null'.

# Opcionalmente, um ou mais n√≥s podem ser destacados em outra
# cor. Para isso, inclua os n√≥s em destaque na lista d. As cadeias xc e xf,
# tamb√©m opcionais, podem ser usadas para inserir comandos adicionais que
# estar√£o presentes no come√ßo e no fim do subprograma dot, respectivamente,
# dentro da estrutura principal 'digraph'.

tipo N√≥:
  inteiro chv
  N√≥ prox

  N√≥(inteiro c):
    chv <- c

N√≥ cab <- N√≥(5)
cab.prox <- N√≥(3)
cab.prox.prox <- N√≥(7)
cab.prox.prox.prox <- N√≥(1)

visual X <- lista_encadeada(cab, "chv", "prox")
visual X <- lista_encadeada(cab, "chv", "prox", verdadeiro)
visual X <- lista_encadeada(cab, "chv", "prox", verdadeiro, [cab.prox])
visual X <- lista_encadeada(cab, "chv", "prox", verdadeiro, [cab.prox],
                            "edge [color=\"red:blue\";]")
visual X <- lista_encadeada(cab, "chv", "prox", verdadeiro, [cab.prox],
                            "", "x [label=\"Veja!\"]; x -> s2:chv:n")

#----------------------------------------------------------------------
## heap(H, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   H (lista unidimensional)
#   d (lista de inteiros)
#   da (lista de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o heap H ser√° renderizado.
# Ele ser√° constru√≠do a partir de um vetor no qual o elemento no √≠ndice i tem
# filhos nos √≠ndices (i+1)*2 e (i+2)*2. O elemento 0 ser√° a raiz.
# Opcionalmente, um ou mais elementos do heap podem ser destacadas em outra
# cor. Para isso, especifique os √≠ndices de destaque na lista d. Para destacar
# arestas, utilize a lista 'da'. Um elemento x na lista 'da' significa que a
# aresta que conecta o pai do elemento no √≠ndice 'da' at√© o elemento no √≠ndice
# 'da' ser√° destacada.

# As cadeias xc e xf s√£o interpretadas da mesma maneira como nas demais fun√ß√µes
# de visualiza√ß√£o.

inteiro H[*] <- [10, 5, 20, 2, 7, 15, 25, 1, 3, 6, 8]
visual X <- heap(H)
visual X <- heap(H, [3, 5, 1])
visual X <- heap(H, [3, 5, 1], [2, 5, 6])
visual X <- heap(H, [3, 5, 1], [2, 5, 6], "edge [decorate=true; label=\"üòä\"];")
visual X <- heap(H, [3, 5, 1], [2, 5, 6], "", "0 [shape=star];")

#----------------------------------------------------------------------
## √°rvore(T, nc, nf, d = [], xc = "", xf = "")

# Par√¢metros:
#   T (estrutura)
#   nc (cadeia)
#   nf (cadeia)
#   d (lista de estruturas)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, a √°rvore com raiz T ser√°
# renderizada. As cadeias nc e nf devem fornecer os nomes dos atributos
# definidos na classe de T que simbolizam, respectivamente, o valor da chave
# e a lista de filhos de um n√≥.

# Opcionalmente, um ou mais n√≥s podem ser destacados em outra
# cor. Para isso, inclua os n√≥s em destaque na lista d. As cadeias xc e xf,
# tamb√©m opcionais, podem ser usadas para inserir comandos adicionais que
# estar√£o presentes no come√ßo e no fim do subprograma dot, respectivamente,
# dentro da estrutura principal 'digraph'.

tipo N√≥:
  inteiro chv
  N√≥ fs[*]

  N√≥(inteiro c):
    chv <- c

N√≥ T, A, B, C, D <- N√≥(5), N√≥(1), N√≥(3), N√≥(2), N√≥(4)
T.fs <- [A, B]
B.fs <- [C, D]

visual X <- √°rvore(T, "chv", "fs")
visual X <- √°rvore(T, "chv", "fs", [B])
visual X <- √°rvore(T, "chv", "fs", [B], "node [shape=doubleoctagon]")
visual X <- √°rvore(T, "chv", "fs", [B], "", "x [label=\"Veja!\"]; x -> 2")

#----------------------------------------------------------------------
## grafo_MA(M, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   M (lista bidimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo descrito pela
# matriz de adjac√™ncia M ser√° renderizado. Uma aresta do grafo existe
# se M[i,j] != 0 e M[j,i] != 0.

# Opcionalmente, v√©rtices e arestas podem ser destacados com cores.
# Para destacar v√©rtices, preencha a lista 'd' com os √≠ndices dos v√©rtices
# a serem destacados. Para destacar arestas, preencha a lista 'da' com
# listas da forma [u, v] para representar uma aresta entre os v√©rtices u e v.

# As cadeias xc e xf, tamb√©m opcionais, podem ser usadas para inserir comandos
# adicionais que estar√£o presentes no come√ßo e no fim do subprograma dot,
# respectivamente, dentro da estrutura principal 'strict graph'.

inteiro G[5, 5] <- [ [ 0, 1, 0, 0, 1],
                     [ 1, 0, 1, 0, 0],
                     [ 0, 1, 0, 0, 0],
                     [ 0, 0, 0, 0, 0],
                     [ 1, 0, 0, 0, 1] ]

visual X <- grafo_MA(G)
visual X <- grafo_MA(G, [4])
visual X <- grafo_MA(G, [4], [[1, 2]])
visual X <- grafo_MA(G, [4], [[1, 2]], "node [style=radial;"
                                       "fillcolor=\"white:purple\"; gradientangle=270];")
visual X <- grafo_MA(G, [4], [[1, 2]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## grafo_LA(L, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   L (lista bidimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo descrito pela
# lista de adjac√™ncia L ser√° renderizado. Uma aresta do grafo existe
# se j ‚àà L[i] e i ‚àà L[j].

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro L[5, *] <- [ [1, 4],
                     [0, 2],
                     [1],
                     [],
                     [0, 4] ]

visual X <- grafo_LA(L)
visual X <- grafo_LA(L, [4])
visual X <- grafo_LA(L, [4], [[1, 2]])
visual X <- grafo_LA(L, [4], [[1, 2]], "node [shape=hexagon];")
visual X <- grafo_LA(L, [4], [[1, 2]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## digrafo_MA(M, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   M (lista bidimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo direcionado
# descrito pela matriz de adjac√™ncia M ser√° renderizado. Uma aresta
# do grafo de i para j existe se M[i,j] != 0.

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro D[5, 5] <- [ [0, 1, 0, 0, 0],
                     [1, 0, 0, 0, 0],
                     [0, 1, 0, 0, 1],
                     [0, 0, 0, 0, 0],
                     [1, 0, 0, 0, 1] ]

visual X <- digrafo_MA(D)
visual X <- digrafo_MA(D, [4])
visual X <- digrafo_MA(D, [4], [[2, 1]])
visual X <- digrafo_MA(D, [4], [[2, 1]], "edge [style=tapered; penwidth=5];")
visual X <- digrafo_MA(D, [4], [[2, 1]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## digrafo_LA(L, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   L (lista bidimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo direcionado
# descrito pela lista de adjac√™ncia L ser√° renderizado. Uma aresta
# do grafo de i para j existe se j ‚àà L[i].

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro L[5, *] <- [ [1],
                     [0],
                     [1, 4],
                     [],
                     [0, 4] ]

visual X <- digrafo_LA(L)
visual X <- digrafo_LA(L, [4])
visual X <- digrafo_LA(L, [4], [[2, 1]])
visual X <- digrafo_LA(L, [4], [[2, 1]], "node [shape=note];")
visual X <- digrafo_LA(L, [4], [[2, 1]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## grafo_valorado_MA(M, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   M (lista bidimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo valorado
# descrito pela matriz de adjac√™ncia M ser√° renderizado. Uma aresta do
# grafo existe com peso M[i,j] se M[i,j] != 0 e M[j,i] != 0.

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro G[5, 5] <- [ [ 0, 4, 0, 0, 8],
                     [ 4, 0, 7, 0, 0],
                     [ 0, 7, 0, 0, 0],
                     [ 0, 0, 0, 0, 0],
                     [ 8, 0, 0, 0, 10] ]

visual X <- grafo_valorado_MA(G)
visual X <- grafo_valorado_MA(G, [4])
visual X <- grafo_valorado_MA(G, [4], [[1, 2]])
visual X <- grafo_valorado_MA(G, [4], [[1, 2]], "edge [style=dashed]")
visual X <- grafo_valorado_MA(G, [4], [[1, 2]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## grafo_valorado_LA(L, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   L (lista tridimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo valorado
# descrito pela lista de adjac√™ncia L ser√° renderizado. Uma aresta do
# grafo existe com peso w se [j, w] ‚àà L[i] e [i, _] ‚àà L[j].

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro L[5, *, 2] <- [ [[1, 4], [4, 8]],
                        [[0, 4], [2, 7]],
                        [[1, 7]],
                        [],
                        [[0, 8], [4, 10]] ]

visual X <- grafo_valorado_LA(L)
visual X <- grafo_valorado_LA(L, [4])
visual X <- grafo_valorado_LA(L, [4], [[1, 2]])
visual X <- grafo_valorado_LA(L, [4], [[1, 2]], "node [shape=cylinder];")
visual X <- grafo_valorado_LA(L, [4], [[1, 2]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## digrafo_valorado_MA(M, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   M (lista bidimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo valorado e
# direcionado descrito pela matriz de adjac√™ncia M ser√° renderizado.
# Uma aresta do grafo de i para j existe com peso M[i,j] se M[i,j] != 0.

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro D[5, 5] <- [ [0, 4, 0, 0, 0],
                     [5, 0, 0, 0, 0],
                     [0, 8, 0, 0, 9],
                     [0, 0, 0, 0, 0],
                     [-1, 0, 0, 0, 7] ]

visual X <- digrafo_valorado_MA(D)
visual X <- digrafo_valorado_MA(D, [4])
visual X <- digrafo_valorado_MA(D, [4], [[2, 1]])
visual X <- digrafo_valorado_MA(D, [4], [[2, 1]], "node [style=wedged; "
                                                  "fillcolor=\"green:yellow:blue\"];")
visual X <- digrafo_valorado_MA(D, [4], [[2, 1]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## digrafo_valorado_LA(L, d = [], da = [], xc = "", xf = "")

# Par√¢metros:
#   L (lista tridimensional de inteiros)
#   d (lista de inteiros)
#   da (lista de pares [u, v] de inteiros)
#   xc (cadeia)
#   xf (cadeia)

# Retorna: Uma cadeia com a descri√ß√£o da estrutura a ser renderizada.

# Caso a cadeia seja armazenada em uma vari√°vel, o grafo valorado e
# direcionado descrito pela lista de adjac√™ncia L ser√° renderizado.
# Uma aresta do grafo existe com peso w se [j, w] ‚àà L[i] e [i, _] ‚àà L[j].

# Os par√¢metros opcionais s√£o equivalentes aos da fun√ß√£o grafo_MA.

inteiro L[5, *, 2] <- [ [[1, 4]],
                        [[0, 5]],
                        [[1, 8], [4, 9]],
                        [],
                        [[0, -1], [4, 7]] ]

visual X <- digrafo_valorado_LA(L)
visual X <- digrafo_valorado_LA(L, [4])
visual X <- digrafo_valorado_LA(L, [4], [[2, 1]])
visual X <- digrafo_valorado_LA(L, [4], [[2, 1]], "node [shape=polygon; peripheries=2; "
                                                  "sides=7; skew=-0.4; distortion=0.7];")
visual X <- digrafo_valorado_LA(L, [4], [[2, 1]], "", "3 [style=invis]")

#----------------------------------------------------------------------
## dot(S)

# Par√¢metros:
#   S (cadeia)

# Retorna: A cadeia S de forma a ser interpretada como instru√ß√µes DOT
#          que ser√£o renderizadas no navegador.

# Armazene o retorno da fun√ß√£o em uma vari√°vel para exibir a imagem
# resultante na visualiza√ß√£o. O exemplo mais trivial √© o de grafo
# n√£o direcionado:

visual X <- dot("graph {A -- B; B -- C; A -- C;}")

# Tamb√©m podemos construir um grafo direcionado (digrafo):

visual X <- dot("digraph {A -> B; B -> C; A -> C;}")

# Podemos alterar propriedades de n√≥s individuais:

visual X <- dot("graph {A [shape=triangle, style=filled, fillcolor=green];"
                "       B [style=wedged, fillcolor=\"cyan:blue:navy\""
                "          label=\"Teste\", fontcolor=white];"
                "       A -- B}")

# Note que √© poss√≠vel o uso de m√∫ltiplas linhas para melhor legibilidade.
# Tamb√©m √© necess√°rio que aspas (") estejam precedidas pelo caracter de
# escape (\) quando elas estiverem contidas na descri√ß√£o DOT.

# Arestas tamb√©m possuem certas propriedades:

visual X <- dot("graph {A -- B [style=dashed, dir=back, penwidth=8]}")

# Para uma lista completa de atributos DOT suportados,
# visite https://www.graphviz.org/doc/info/attrs.html .

# Embora mais complexo, tamb√©m √© poss√≠vel estilizar um n√≥ para que seja
# exibido como uma tabela, e seu conte√∫do deve ser descrito atrav√©s
# de um subconjunto da sintaxe HTML:

visual X <- dot("graph {T [shape=plaintext, label="
                "  <<TABLE BORDER='2' CELLSPACING='5'>"
                "    <TR>"
                "      <TD><FONT POINT-SIZE='20'><I> Um </I></FONT></TD>"
                "      <TD BORDER='0'><FONT COLOR='RED'> Dois </FONT></TD>"
                "    </TR>"
                "    <TR>"
                "      <TD><FONT FACE='Courier'> Tr√™s </FONT></TD>"
                "      <TD BGCOLOR='GRAY:WHITE' GRADIENTANGLE='45'> Quatro </TD>"
                "    </TR>"
                "  </TABLE>>]}")

# Para uma lista completa de atributos HTML suportados,
# visite https://www.graphviz.org/doc/info/shapes.html#html .

#----------------------------------------------------------------------
